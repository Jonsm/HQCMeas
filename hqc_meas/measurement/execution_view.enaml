# -*- coding: utf-8 -*-
#==============================================================================
# module : execution_view.enaml
# author : Matthieu Dartiailh
# license : MIT license
#==============================================================================
from enaml.core.api import Looper
from enaml.layout.api import hbox, spacer, vbox, grid, align
from enaml.widgets.api import (PushButton, Menu, Action, Container, Stack,
                               StackItem, CheckBox, Border, DockItem, Dialog,
                               Label, Form, Field, GroupBox, MultilineField)
import os

from hqc_meas.utils.widgets.list_editor import ListEditor
from hqc_meas.utils.widgets.qt_list_str_widget import QtListStrWidget

from .monitoring_views import EditMonitorView
from .edition_view import MeasEditorDialog


enamldef MeasView(GroupBox): widget:
    """ Simple visual summary of a measure.

    """
    attr measure

    constraints = [vbox(hbox(sta_lab, sta_val, spacer),
                        hbox(edit, spacer, use_mon, edit_mon))]
    Label: sta_lab:
        text = 'Status :'
    Label: sta_val:
        text << measure.status
        tool_tip << measure.infos

    # TODO todo
    PushButton: edit:
        text = 'Edit measure'
        clicked ::
            meas_editor = MeasEditorDialog(parent = widget,
                                            meas = model)
            model.monitor.status = 'EDITING'
            default_path = model.root_task.default_path
            meas_editor.exec_()

            task = model.root_task
            path = os.path.join(default_path,
                            model.monitor.measure_name + '_last_run.ini')
            if task.default_path == default_path:
                model.save_measure(path)
            else:
                os.remove(path)
                path = os.path.join(task.default_path,
                            model.monitor.measure_name + '_last_run.ini')
                model.save_measure(path)

            model.monitor.status = 'READY'

    # TODO create monitor edition view
    PushButton: edit_mon:
        text = 'Edit'
        clicked ::
            EditMonitorView(monitor = model.monitor).exec_()
            path = os.path.join(default_path,
                            model.monitor.measure_name + '_last_run.ini')
            model.save_measure(path)


enamldef ExecutionView(DockItem):

    attr workspace
    closable = False

    Container:
        constraints << [vbox(ed,
                            hbox(start, spacer, stop, stop_all),
                            hbox(spacer, mon))]

        ListEditor(MeasView): ed:
            ed.model << workspace.plugin
            ed.iterable_name = 'enqueued_measures'
            ed.operations = ['move', 'delete']

        PushButton: start:
            text = 'Start'
            enabled << bool(workspace.plugin.enqueued_measures) \
                and not 'processing' in workspace.plugin.flags
            clicked ::
                workspace.start_processing_measures()
        PushButton: stop:
            text = 'Stop task'
            enabled << 'processing' in workspace.plugin.flags
            clicked ::
                workspace.stop_current_measure()
            Menu:
                Action:
                    text = 'Force measure stop'
                    enabled << 'attempt_stop' in workspace.plugin.flags
                    triggered::
                        workspace.force_stop_measure()
        PushButton: stop_all:
            text = 'Stop all'
            enabled << 'processing' in workspace.plugin.flags
            clicked ::
                workspace.stop_processing()
            Menu:
                Action:
                    text = 'Force processing stop'
                    enabled << 'attempt_stop' in workspace.plugin.flags
                    triggered::
                        workspace.force_stop_processing()

        PushButton: mon:
            text = 'Open monitors'
            enabled << 'processing' in workspace.plugin.flags
            clicked::
                monitors = workspace.plugin.running_measure.monitors.values()
                for monitor in monitors:
                    monitor.show_monitor()


