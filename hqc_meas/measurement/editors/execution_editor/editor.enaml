# -*- coding: utf-8 -*-
# =============================================================================
# module : editor.enaml
# author : Matthieu Dartiailh
# license : MIT license
# =============================================================================
from atom.api import Atom, Value, Typed, List
from enaml.widgets.api import (Container, GroupBox, CheckBox, ScrollArea,
                               PopupView, RadioButton, Field, ToolButton,
                               ObjectCombo, PushButton)
from enaml.core.api import Looper, Conditional
from enaml.stdlib.mapped_view import MappedView
from enaml.layout.api import hbox, spacer
from inspect import cleandoc
from collections import Counter

from hqc_meas.tasks.api import ComplexTask, SimpleTask
from hqc_meas.tasks.tools.walks import flatten_walk
from hqc_meas.utils.widgets.qt_line_completer import QtLineCompleter
from ..base_editor import BaseEditor



class _Model(Atom):
    """

    """
    root = Value()

    pools = List()

    def bind_observers(self):
        """

        """
        counter = Counter()
        self._bind_observers(self.root, counter)

        self._counter = counter
        self.pools = list(set(counter.elements()))

    def unbind_observers(self):
        """

        """
        self._unbind_observers(self.root, Counter())

    # --- Private API ---------------------------------------------------------

    _counter = Typed(Counter, ())

    def _bind_observers(self, task, counter):
        """

        """
        if isinstance(task, ComplexTask):
            task.observe('children_task', self._children_observer)
            for child in task._gather_children_task():
                self._bind_observers(child, counter)

        else:
            pools = []
            parallel = task.parallel
            if parallel.get('activated'):
                pool = parallel['pool']
                if pool:
                    pools.append(pool)

            wait = task.wait
            if wait.get('activated'):
                pools.extend(wait.get('wait', []))
                pools.extend(wait.get('no_wait', []))

            counter.update(pools)

            task.observe('parallel', self._task_observer)
            task.observe('wait', self._task_observer)

    def _unbind_observers(self, task, counter):
        """

        """
        if isinstance(task, ComplexTask):
            task.unobserve('children_task', self._children_observer)
            for child in task._gather_children_task():
                self._unbind_observers(child, counter)

        else:
            pools = []
            parallel = task.parallel
            if parallel.get('activated'):
                pool = parallel['pool']
                if pool:
                    pools.append(pool)

            wait = task.wait
            if wait.get('activated'):
                pools.extend(wait.get('wait', []))
                pools.extend(wait.get('no_wait', []))

            counter.subtract(pools)

            task.unobserve('parallel', self._task_observer)
            task.unobserve('wait', self._task_observer)

    def _observe_root(self, change):
        """

        """
        if 'oldvalue' in change and change['oldvalue']:
            self.unbind_observers(change['oldvalue'])

        root = change['value']
        if root:
            self.bind_observers()

    def _task_observer(self, change):
        """

        """
        if change['name'] == 'parallel':
            activated = change['value'].get('activated')
            pool = change['value'].get('pool')
            if not activated and pool:
                self._counter[pool] -= 1
                self.pools = list(set(self._counter.elements()))

            elif activated and pool:
                self._counter[pool] += 1
                self.pools = list(set(self._counter.elements()))

        else:
            activated = change['value'].get('activated')
            wait = change['value'].get('wait', [])
            no_wait = change['value'].get('no_wait', [])
            counter = Counter(wait + no_wait)

            if not activated and counter:
                self._counter.substract(counter)
                self.pools = list(set(self._counter.elements()))

            elif activated and counter:
                self._counter.update(counter)
                self.pools = list(set(self._counter.elements()))

    def _children_observer(self, change):
        """

        """
        added = set(change['value']) - set(change.get('oldvalue', []))
        removed = set(change.get('oldvalue', [])) - set(change['value'])

        counter = Counter()

        for child in removed:
            self._unbind_observers(child, counter)

        for child in added:
            self._bind_observers(child, counter)

        self._counter.update(counter)
        self.pools = list(set(counter.elements()))


enamldef _PopupField(PopupView): popup:
    """

    """
    Container:
        constraints = [vbox(field, hbox(ok, cancel))]

        Field: field:
            submit_triggers = ['lost_focus', 'return_pressed', 'auto_sync']
        PushButton: ok:
            enabled << bool(field.text)
            text = 'Ok'
            clicked ::
                popup.close()
                popup.parent.answer = field.text
        PushButton: cancel:
            text = 'Cancel'
            clicked ::
                popup.close()

enamldef _PopupList(PopupView): popup:
    """

    """
    attr pools
    attr selected : set
    Container:
        constraints = [vbox(area, hbox(ok, cancel))]

        ScrollArea: area:
            Container:
                padding = 0
                Looper:
                    iterable = pools
                    CheckBox:
                        text = loop_item
                        checked << loop_item in selected
                        checked::
                            if change['value']:
                                selected.add(loop_item)
                            else:
                                selected.remove(loop_item)
        PushButton: ok:
            text = 'Ok'
            clicked ::
                popup.close()
                popup.parent.answer = selected
        PushButton: cancel:
            text = 'Cancel'
            clicked ::
                popup.close()


enamldef _SimpleExEditor(GroupBox):

    attr task
    attr _model
    attr _map
    attr _lock : bool = False

    title = task.task_name

    constraints << [hbox(stop, parallel, wait,
                         *tuple(par_cond.items + wai_cond.items))]

    CheckBox: stop:
        text = 'Stoppable'
        checked := task.stoppable
        tool_tip = cleandoc('''Can the program be stopped or paused at this
                            task. Disabling allow to skip some check and might
                            be beneficial in very tight loops.''')
        hug_width = 'strong'

    CheckBox: parallel:
        text = 'Parallel'
        tool_tip = cleandoc('''Should this task perform its job in parallel
                            (new thread).''')
        hug_width = 'strong'
        checked << bool(task.parallel.get('activated'))
        checked ::
            if not self.parent._lock:
                self.parent._lock = True
                aux = task.parallel.copy()
                aux['activated'] = change['value']

                # Avoid rebuilding twice perform_
                with task.suppress_notifications():
                    task.wait['activated'] = False

                task.parallel = aux

                if change['value']:
                    wait.checked = False

                self.parent._lock = False

    CheckBox: wait:
        text = 'Wait'
        tool_tip = cleandoc('''Should this task wait for any other task
                            currently working in parallel.''')
        hug_width = 'strong'
        checked << bool(task.wait.get('activated'))
        checked ::
            if not self.parent._lock:
                self.parent._lock = True
                aux = task.wait.copy()
                aux['activated'] = change['value']

                # Avoid rebuilding twice perform_
                with task.suppress_notifications():
                    task.parallel['activated'] = False

                task.wait = aux

                if change['value']:
                    parallel.checked = False

                self.parent._lock = False

    Conditional: par_cond:
        condition << parallel.checked

        ObjectCombo:
            items << _model.pools
            selected << task.parallel.get('pool')
            selected ::
                aux = task.parallel.copy()
                aux['pool'] = change['value']
                task.parallel = aux

        PushButton:
            attr answer
            text = 'New'
            hug_width = 'strong'

            initialized::
                self.answer = '__gg__'
            clicked ::
                popup = _PopupField(self)
                popup.show()
            answer ::
                aux = task.parallel.copy()
                aux['pool'] = change['value']
                task.parallel = aux

    Conditional: wai_cond:
        condition << wait.checked
        attr selected = set(task.wait.get('wait', []) +
                                task.wait.get('no_wait', []))

        RadioButton:
            text = 'Wait on'
            tool_tip = 'Wait on the list of selected pools.'
            checked << 'no_wait' not in task.wait
            checked ::
                task.wait = dict(activated=True, wait=list(selected))

        RadioButton:
            text = 'No wait on'
            tool_tip = "Don't wait on the selected pools."
            checked << 'no_wait' in task.wait
            checked ::
                task.wait = dict(activated=True, no_wait=list(selected))

        Field:
            read_only = True
            text << ', '.join(wai_cond.selected)
            hug_width = 'ignore'

        PushButton:
            attr answer
            text = 'Edit'
            hug_width = 'strong'

            initialized::
                self.answer = ['']
            clicked ::
                sel = wai_cond.selected.copy()
                popup = _PopupList(self, selected=sel, pools=_model.pools)
                popup.show()
            answer ::
                new_sel = change['value']
                wai_cond.selected = new_sel
                if 'no_wait' in task.wait:
                    task.wait = dict(activated=True, no_wait=list(new_sel))
                else:
                    task.wait = dict(activated=True, wait=list(new_sel))


enamldef _ComplexExEditor(GroupBox):

    attr task
    attr _model
    attr _map

    title = task.task_name if task else ''

    Looper:
        iterable << task._gather_children_task() if task else []
        MappedView:
            model = loop_item
            typemap = _map
            kwargs = {'_model': _model, '_map': _map}
            modelkey = 'task'

enamldef _EmptyEd(GroupBox):

    attr task
    attr _model
    attr _map


enamldef ExecutionEditor(BaseEditor): editor:
    """

    """
    attr pool_model = _Model()
    attr _map = {SimpleTask: _SimpleExEditor, ComplexTask: _ComplexExEditor,
                 type(None): _EmptyEd}

    title = 'Execution editor'
    name = 'execution_editor'

    selected ::
        task.model = None
        pool_model.root = selected_task.root_task
        pool_model.bind_observers()
        task.model = selected_task

    unselected ::
        pool_model.unbind_observers()

    Container:
        ScrollArea:
            MappedView: task:
                model << selected_task
                typemap = _map
                kwargs = {'_model': pool_model, '_map': _map}
                modelkey = 'task'
