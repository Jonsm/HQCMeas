# -*- coding: utf-8 -*-
#==============================================================================
# module : edition_view.enaml
# author : Matthieu Dartiailh
# license : MIT license
#==============================================================================
from atom.api import Typed, ContainerList, Instance
from enaml.stdlib.mapped_view import MappedView
from enaml.layout.api import hbox, spacer, vbox, align
from enaml.widgets.api import (PushButton, Menu, Action, Container, Dialog,
                               Label, Field, CheckBox, GroupBox, Notebook,
                               DockItem)
from enaml.core.api import Conditional

from hqc_meas.utils.widgets.qt_tree_widget import QtTreeWidget
from hqc_meas.utils.widgets.tree_nodes import TreeNode
from hqc_meas.utils.widgets.qt_tree_menu import \
    (CopyAction, CutAction, PasteAction, NewAction, RenameAction, DeleteAction)

from hqc_meas.tasks.api import (BaseTask, SimpleTask, ComplexTask)
from .editors.base_editor import BaseEditor
from .workspace import MeasureSpace


enamldef SaveAction(Action):

    text = 'Save template'
    attr action_context
    triggered ::
        widget, node, obj, nid = action_context['data']
        # TODO use core
#        save_task(obj, mode='template')


enamldef SimpleMenu(Menu): menu:
    """ Menu for simple tasks.

    """
    attr context
    attr workspace

    NewAction:
        action_context << context
        factory = build_task
        mode = 'Add before'
        kwargs = {'parent_ui': menu}
    NewAction:
        action_context << context
        factory = build_task
        mode = 'Add after'
        kwargs = {'parent_ui': menu}
    Action:
        separator = True
    CutAction:
        action_context << context
    CopyAction:
        action_context << context
    PasteAction:
        action_context << context
    Action:
        separator = True
    DeleteAction:
        action_context << context
    Action:
        separator = True
    RenameAction:
        action_context << context


enamldef ComplexMenu(Menu): menu:
    """ Menu for complex tasks.

    """
    attr context
    attr workspace

    NewAction:
        action_context << context
        factory = build_task
        kwargs = {'parent_ui': menu}
    Action:
        separator = True
#    SaveAction:
#        action_context << context
    Action:
        separator = True
    CutAction:
        action_context << context
    CopyAction:
        action_context << context
    PasteAction:
        action_context << context
    Action:
        separator = True
    DeleteAction:
        action_context << context
    Action:
        separator = True
    RenameAction:
        action_context << context


class _MeasEditionModel(Atom):
    """
    """
    # Instance of the workspace
    workspace = Typed(MeasureSpace)

    # Currently selected task.
    selected_task = Instance(BaseTask)

    # List of all editors which can be used given the selected_task
    valid_editors = ContainerList(Instance(BaseEditor))

    # Currently selected editor.
    selected_editor = Instance(BaseEditor)

    # Should the tree be enabled given the currenlty selected editor.
    tree_enabled = Bool(True)

    # Should the tree be visible given the currently selected editor.
    tree_visible = Bool(True)

    def _observe_selected_task(self, change):
        """ Keep the list of valid editors up to date and update editor.

        """
        editors = self.workspace.plugin.editors
        new_task = change['value']
        valid_editor_ids = set()

        # Find all valid editors.
        for id, editor in editors.iteritems():
            if editor.test(self.workspace, new_task):
                valid_editor_ids.add(id)

        # If there are some changes apply them by append remove so that if the
        # the currently selected editor remains nothing changes.
        current_editor_ids = set([editor.id for editor in self.valid_editors])
        if valid_editor_ids != current_editor_ids:
            to_remove = current_editor_ids - valid_editor_ids
            to_add = valid_editor_ids - current_editor_ids
            for editor in self.valid_editors[:]:
                if editor.id in to_remove:
                    self.valid_editors.remove(editor)

            for id in to_add:
                editor = editors[id].factory(workspace.workbench)
                self.valid_editors.append(editor)

        # Update selected editor with new selected task. If the editor changed
        # notifications will have taken care of that.
        self.selected_editor.selected_task = new_task

    def _observe_selected_editor(self, change):
        """ Update infos for newly selected editor.

        """
        editor = change['value']
        # Update selected task.
        editor.selected_task = self.selected_task

        # Get tree preferences.
        self.tree_enabled = editor.tree_enabled
        self.tree_visible = editor.tree_visible


def _selected_page_finder(pages, selected_tab):
    """ Helper function to get the selected page in a notebook.

    WARNING : Qt specific.

    """
    for page in pages:
        if page.titleproxy_is_active \
                and page.proxy.objectName() == selected_tab:
            return page


enamldef MeasEditionView(Container):
    """ Main view for measurement edition

    """
    attr workspace
    attr selected_task << workspace.plugin.edited_measure.root_task
    selected_task >> _internal.selected_task

    attr _internal = _MeasEditionModel(workspace=workspace)

    constraints << [vbox(
                        hbox(lab, name, edition),
                        hbox(tree, task_view)
                        ),
                    align('v_center', lab, name)]

    Label: lab:
        text = 'Name'
    Field: name:
        hug_width = 'ignore'
        text := meas.monitor.measure_name
    PushButton: edition:
        text = 'Edit'
        tool_tip = 'Edit monitors, headers, and checks linked to the measure.'
        clicked ::
            #TODO implement
            pass


    QtTreeWidget: tree:
        hug_height = 'ignore'
        root_node << meas.root_task
        selected >> selected_task
        visible << _internal.tree_enabled
        enabled << _internal.tree_visible
        nodes = [TreeNode(
                    node_for  = [ComplexTask],
                    auto_open = True,
                    children  = 'children_task',
                    label     = 'task_label',
                    add = [BaseTask],
                    menu = ComplexMenu(workspace=workspace)),
                TreeNode(
                    node_for  = [SimpleTask],
                    auto_open = True,
                    children  = '',
                    label     = 'task_label',
                    menu      =  SimpleMenu(workspace=workspace))),
                    ]

    Notebook: editors:
        # Update the selected editor when the user click a tab or when the
        # previously selected editor is removed.
        selected_tab ::
            _internal.selected_editor = _selected_page_finder(pages,
                                                              selected_tab)
        Include:
            objects << _internal.valid_editors.values()


# Still TODO above is ok
enamldef MeasEditorContainer(DockItem): widget:
    alias meas : view.meas
    alias selected : view.selected_task
    attr handler = EditorHandler()
    alias enqueue_clicked : enqueue_button.clicked

    Container:
        constraints = [vbox(view,
                            hbox(new, save, save_template, load, load_template,
                                spacer, enqueue_button))]
        MeasView: view:
            pass
        PushButton: new:
            text = 'New'
            hug_width  = 'strong'
            hug_height = 'strong'
            clicked :: handler.new_clicked(widget)
        PushButton: save:
            text = 'Save'
            hug_width  = 'strong'
            hug_height = 'strong'
            clicked :: handler.save_clicked(widget)
        PushButton: save_template:
            text = 'Save as template'
            hug_width  = 'strong'
            hug_height = 'strong'
            clicked :: handler.save_template_clicked(widget)
        PushButton: load:
            text = 'Load'
            hug_width  = 'strong'
            hug_height = 'strong'
            clicked :: handler.load_clicked(widget)
        PushButton: load_template:
            text = 'Load template'
            hug_width  = 'strong'
            hug_height = 'strong'
            clicked :: handler.load_template_clicked(widget)
        PushButton: enqueue_button:
            text = 'Enqueue'
            hug_width  = 'strong'
            hug_height = 'strong'

enamldef MeasEditorDialog(Dialog): widget:
    alias meas : view.meas
    attr handler = EditorHandler()
    always_on_top = True
    Container:
        constraints = [vbox(view, hbox(save, save_template, spacer))]
        MeasView: view:
            meas << widget.meas
        PushButton: save:
            text = 'Save'
            hug_width  = 'strong'
            hug_height = 'strong'
            clicked ::
                handler.save_clicked(widget)
        PushButton: save_template:
            text = 'Save as template'
            hug_width  = 'strong'
            hug_height = 'strong'
            clicked ::
                handler.save_template_clicked(widget)
