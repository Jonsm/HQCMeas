# -*- coding: utf-8 -*-

from enaml.widgets.api import (DockItem, Container, ObjectCombo, Label,
                               GroupBox, Notebook, Page, PushButton,
                               MultilineField, Field, ScrollArea, PopupView)
from enaml.core.api import (Looper, Conditional, Include)
from enaml.layout.api import grid, vbox, hbox, spacer
from enaml.stdlib.mapped_view import MappedView
from inspect import cleandoc, getdoc, getargspec, formatargspec
from textwrap import fill


def f_c(str, length=80):
    return fill(cleandoc(str), length)


def _form_maker(form_tuple):
    """ Helper function building the form for editing custom profiles.

    """
    if form_tuple and form_tuple != (None, None):
        return [form_tuple[1](model=form_tuple[0], mode='new')]
    else:
        return []

def _method_call(model, meth, f_args, f_kwargs):
    """ Helper function attempting to call a method.

    """
    if f_args.text:
        try:
            args = eval('(' + f_args.text + ',)')
        except:
            model.errors += 'Failed to evaluate args'
            return
    else:
        args = ()

    if f_kwargs.text:
        try:
            aux = f_kwargs.text.replace('=', ':')
            kwargs = eval('{' + aux + '}')
        except:
            errors.text += 'Failed to evaluate kwargs'
            return
    else:
        kwargs = {}

    call = model.attempt_call(meth.selected, args, kwargs)
    mess = ''

    if isinstance(call, Exception):
        mess = f_c('''Call to {} failed with error
                    {}.'''.format(meth.selected.__name__,
                                  call.message))
    else:
        mess = f_c('''Call to {} succeeded and
            returned {}.'''.format(meth.selected.__name__,
                                   call))
    model.errors += mess + '\n'

def _method_doc(method):
    """ Helper function buiilding the doc of a method.

    """
    name = method.__name__
    signature = formatargspec(*getargspec(method))
    doc = getdoc(method) if getdoc(method) else ''

    full_doc = name + signature + ':\n\n' + doc
    full_doc.strip()
    return full_doc


enamldef SetGetBox(GroupBox):
    """ Widget generating getter/setter fields for a list a attributes

    """
    alias iterable : loop.iterable

    constraints << [grid(*loop.items)] +\
                   [line[1].width == line[3].width
                   for line in loop.items] +\
                   [line[2].width == 20
                   for line in loop.items] +\
                   [line[4].width == 20
                   for line in loop.items]
    padding = 2

    Looper: loop:
        Label:
            text << loop_item
        Field: getter:
            read_only = True
        PushButton:
            text = '<'
            clicked ::
                aux = debugger.attempt_get(loop_item)
                if isinstance(aux, Exception):
                    getter.background = 'red'
                    getter.tool_tip = aux.message
                else:
                    getter.background = 'white'
                    if isinstance(aux, basestring):
                        getter.text = '"' + aux + '"'
                    else:
                        getter.text = str(aux)
        Field: setter:
            submit_triggers = ['lost_focus', 'return_pressed',
                               'auto_sync']
            tool_tip = f_c('''Enter the value to send to
                the driver as in a python interpreter''')
            text ::
                setter.background = 'white'
        PushButton:
            text = '>'
            clicked ::
                setter.background = 'turquoise'
                aux = debugger.attempt_set(loop_item, setter.text)
                if isinstance(aux, Exception):
                    setter.background = 'red'
                    setter.tool_tip = f_c('''The last
                        attempt to set the driver value failed
                        with the exception :
                        {}'''.format(aux.message))
                    print setter.tool_tip
                else:
                    setter.background = 'green'
                    setter.tool_tip = f_c('''Enter the
                        value to send to the driver as in a
                        python interpreter''')

enamldef DocPopup(PopupView):
    """ Popup view to display method signature and doc.

    """
    alias text: field.text
    Container:
        MultilineField: field:
            pass


enamldef DriverDebuggerView(DockItem): main:

    attr debugger

    title = 'Driver debugger'

    Container:
        constraints << [vbox(
                            hbox(dr_lab, dr, spacer),
                            prof,
                            hbox(dr_start, conn_o, conn_c, conn_r, dr_close,
                                 dr_reload),
                            *tuple(cond.items + [err, clear])
                            ),
                        dr_start.width == conn_o.width,
                        conn_o.width == conn_c.width,
                        conn_c.width == conn_r.width,
                        conn_r.width == dr_reload.width,
                        dr_reload.width == dr_close.width,
                        ]

        # Driver selection.
        Label: dr_lab:
            text = 'Driver'
        ObjectCombo: dr:
            enabled << debugger.driver_instance is None
            items << debugger.instr_manager_state.drivers
            selected = None
            selected ::
                debugger.driver = selected
                clear.clicked()

        # Profile selection.
        GroupBox: prof:
            enabled << debugger.driver_instance is None
            hug_height = 'strong'
            title = 'Instrument profile'
            Notebook:
                tabs_closable = False
                tabs_movable = False
                size_hint_mode = 'current'
                selected_tab ::
                    if change['value'] == 'predef':
                        debugger.profile = p_prof.selected
                    else:
                        debugger.profile = None
                Page:
                    name = 'predef'
                    title = 'Predefined'
                    Container:
                        ObjectCombo: p_prof:
                            items << debugger.profiles
                            items ::
                                selected = None
                            selected = None
                            selected >> debugger.profile

                Page:
                    name = 'custom'
                    title = 'Custom'
                    Container:
                        Include: form:
                            objects << _form_maker(debugger.custom_form)
                        PushButton: form_val:
                            text = 'Validate form'
                            background << 'green' if\
                                            isinstance(main.debugger.profile,
                                                       dict) else 'red'
                            enabled << bool(debugger.custom_form
                                            != (None, None))
                            clicked ::
                                aux = main.debugger.custom_form[0]
                                if aux.check():
                                    main.debugger.profile = aux.connection_dict()

        # Main buttons.
        PushButton: dr_start:
            text = 'Start driver'
            enabled << bool(debugger.driver_instance is None
                            and debugger.driver_ready)
            clicked ::
                debugger.start_driver()
        PushButton: conn_o:
            text = 'Open connection'
            enabled << bool(not debugger.connected and debugger.driver_ready
                            and debugger.driver_instance)
            clicked ::
                debugger.open_connection()
        PushButton: conn_c:
            text = 'Close connection'
            enabled << debugger.connected
            clicked ::
                debugger.close_connection()
        PushButton: conn_r:
            text = 'Reopen connection'
            enabled << debugger.connected
            clicked ::
                debugger.reopen_connection()
        PushButton: dr_close:
            text = 'Close driver'
            enabled << debugger.driver_instance is not None
            clicked ::
                debugger.close_driver()
        PushButton: dr_reload:
            text = 'Reload driver'
            enabled << bool(debugger.driver
                            and debugger.driver_instance is None)
            clicked ::
                debugger.reload_driver()

        # Driver interface.
        Conditional: cond:
            condition << debugger.driver_instance is not None
            # Attributes and instrument properties
            ScrollArea:
                Container:
                    SetGetBox:
                        title = 'Attributes'
                        iterable << debugger.driver_attributes

                    SetGetBox:
                        title = 'Instrument properties'
                        iterable << debugger.driver_properties

            # Method caller.
            Container:
                padding = 2
                constraints << [hbox(
                                    vbox(hbox(meth, doc),
                                         g_args,
                                         g_kwargs),
                                     vbox(spacer, call_button)),
                                    ]
                ObjectCombo: meth:
                    items << debugger.driver_methods
                    to_string = lambda x : x.__name__
                    selected ::
                        f_args.text = ''
                        f_kwargs.text = ''
                PushButton: doc:
                    text = 'Doc'
                    clicked ::
                        if meth.selected:
                            f_doc = _method_doc(meth.selected)
                            DocPopup(doc, text=f_doc).show()
                GroupBox: g_args:
                    title = 'Args'
                    Field: f_args:
                        tool_tip = f_c('''Enter the positional arguments
                            of the selected method''')
                GroupBox: g_kwargs:
                    title = 'Kwargs'
                    Field: f_kwargs:
                        tool_tip = f_c('''Enter the keyword arguments of
                            the selected method''')
                PushButton: call_button:
                    text = 'Call'
                    clicked ::
                        _method_call(debugger, meth, f_args, f_kwargs)

        # Error display
        MultilineField: err:
            text << debugger.errors
            read_only = True
        PushButton: clear:
            text = 'Clear'
            clicked ::
                debugger.errors = ''
