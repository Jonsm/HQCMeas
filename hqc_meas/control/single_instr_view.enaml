from atom.api import Atom, Bool, Str, Value, Int, observe
from inspect import cleandoc
from textwrap import fill
from time import sleep
from enaml.colors import ColorMember
from enaml.application import deferred_call
from enaml.core.api import Conditional, Include
from enaml.widgets.api import (Container, ObjectCombo, GroupBox, DockItem,
                            PushButton, Field, Dialog, CheckBox, Label, ToolBar,
                            Action, MultilineField)
from enaml.stdlib.fields import (FloatField, IntField)
from enaml.stdlib.message_box import question
from enaml.layout.api import hbox, align

from .single_instr_panel import SingleInstrPanel

STATE_COLOR_MAP = {'normal'  : 'white',
                   'edited' : 'turquoise',
                   'processing' : 'blue',
                   'error'   : 'red'}

class ValidatorModel(Atom):
    """
    """
    dual_display = Bool()
    model        = Value()
    name         = Str()
    ui_val       = Value()
    state        = Str('normal')
    err_message  = Str()
    _safe        = Bool(True)
    _prop        = Int()

    def __init__(self, model, name):
        super(ValidatorModel, self).__init__(model = model, name = name)
        self.ui_val = getattr(model, name)
        model.observe(name, self.post_model_update)
        model.observe('validate_all', self.update_model)
        model.observe('cancel_all', self.cancel_edition)
        model.observe('propose_val', self.catch_val_proposition)
        model.observe('dsetter_report', self.catch_dset_report)

    def __del__(self):
        model = self.model
        model.unobserve(self.name, self.post_model_update)
        model.unobserve('validate_all', self.update_model)
        model.unobserve('cancel_all', self.cancel_edition)
        model.unobserve('propose_val', self.catch_val_proposition)
        model.unobserve('dsetter_report', self.catch_dset_report)

    def post_model_update(self, change):
        """
        """ 
        if self._safe and self.state == 'normal':
            deferred_call(setattr, self, 'ui_val', change['value'])

    def update_model(self, change = {}):
        """
        """
        self._safe = False
        self.state = 'processing'
        self.model.update_driver(self.name, self.ui_val)    

    def cancel_edition(self, change = {}):
        """
        """
        self.ui_val = getattr(self.model, self.name)
        self.dual_display = False
        if self._prop:
            self._prop = 1
            self._proposed_val_counter -= 1

    def catch_dset_report(self, change):
        """
        """
        report = change['value']
        if report[0] == self.name :
            deferred_call(self._process_dset_report, report[1])

    def catch_val_proposition(self, change):
        """
        """
        new = change['value']
        if isinstance(new, dict) and self.name in new:
            proposed_val = change['value'][self.name]
            if proposed_val != getattr(self.model, self.name):
                self._prop = 2
                self.model._proposed_val_counter += 1
                self.dual_display = True
                self.ui_val = change['value'][self.name]
                self.state = 'edition'
                self.err_message = ''
        else:
            self._prop = 0
            
    def _process_dset_report(self, report):
        """
        """
        if isinstance(report, Exception):
            self.state = 'error'
            gen_mess = cleandoc('''An error occured when attempting to set
                        the instrument attribute {} to {}, the driver error
                        message is :'''.format(self.name, self.ui_val))
            mess = report.message
            self.err_message = fill(' '.join([gen_mess, mess]))
            self.dual_display = True
        else:
            self.state = 'normal'
            self._safe = True
            self.dual_display = False
            if self._prop:
                self._prop = 1
                self.model._proposed_val_counter -= 1        
        
    def _observe_ui_val(self, change):
        """
        """
        if change['value'] == getattr(self.model, self.name):
            self.state = 'normal'
        else:
            self.state = 'edited'

def validator_layout(field, cancel, ok, cond_items):
    """
    """
    if cond_items:
        return [hbox(cond_items[0], field, cancel, ok),
                cond_items[0].width == field.width,
                align('v_center', field, cancel),
                align('v_center', field, button)]
    else:
        return [hbox(field, cancel, ok),
                align('v_center', field, cancel),
                align('v_center', field, button)]
    

enamldef FloatValidator(GroupBox):
    attr model
    attr member
    alias minimum : field.minimum
    alias maximum : field.maximum
    attr _internal = ValidatorModel(model, member)

    padding = 2
    constraints << validator_layout(field, cancel, ok, cond.items)
    title << member.capitalize()
    hug_height = 'strong'

    Conditional: cond:
        condition << _internal.dual_display
        Field:
            read_only = True
            text << str(getattr(model, member))
    FloatField: field:
        value := _internal.ui_val
        background << STATE_COLOR_MAP[_internal.state]
        tool_tip << _internal.err_message
        hug_width = 'ignore'
        submit_triggers = ['lost_focus', 'return_pressed', 'auto_sync']
    PushButton: cancel:
        constraints = [width == 15, height == 20]
        font = 'bold 12pt Consolas'
        text = 'C'
        clicked::
            _internal.cancel_edition()
    PushButton: ok:
        constraints = [width == 15, height == 20]
        font = 'bold 12pt Consolas'
        text = '>'
        clicked::
            _internal.update_model()

enamldef IntValidator(GroupBox):
    attr model
    attr member
    alias minimum : field.minimum
    alias maximum : field.maximum
    attr _internal = ValidatorModel(model, member)

    padding = 2
    constraints = validator_layout(field, cancel, button, cond.items)
    title << member.capitalize()
    hug_height = 'strong'

    Conditional: cond:
        condition << _internal.dual_display
        Field:
            read_only = True
            text << str(getattr(model, member))
    IntField: field:
        value := _internal.ui_val
        background << STATE_COLOR_MAP[_internal.state]
        tool_tip << _internal.err_message
    PushButton: cancel:
        constraints = [width == 15, height == 20]
        font = 'bold 12pt Consolas'
        text = 'C'
        clicked::
            _internal.cancel_edition()
    PushButton: ok:
        constraints = [width == 15, height == 20]
        font = 'bold 12pt Consolas'
        text = '>'
        clicked::
            _internal.update_model()
        
enamldef BoolValidator(GroupBox):
    attr model
    attr member
    attr _internal = ValidatorModel(model, member)

    padding = 2
    constraints = [hbox(hbox(*cond.items), box, button)]
    title << member.capitalize()
    hug_height = 'strong'

    Conditional: cond:
        condition << _internal.dual_display
        Field:
            read_only = True
            text << str(getattr(model, member))
    CheckBox: box:
        checked := _internal.ui_val
        background << STATE_COLOR_MAP[_internal.state]
        tool_tip << _internal.err_message
    PushButton: button:
        constraints = [width == 15, height == 20]
        font = 'bold 12pt Consolas'
        text = '>'
        clicked::
            _internal.update_model()

enamldef EnumValidator(GroupBox):
    attr model
    attr member
    attr _internal = ValidatorModel(model, member)

    padding = 2
    constraints = validator_layout(field, cancel, button, cond.items)
    title << member.capitalize()
    hug_height = 'strong'

    Conditional: cond:
        condition << _internal.dual_display
        Field:
            read_only = True
            text << str(getattr(model, member))
    ObjectCombo: field:
        selected := _internal.ui_val
        items << sorted(model.get_member(name).items)
        background << STATE_COLOR_MAP[_internal.state]
        tool_tip << _internal.err_message
    PushButton: cancel:
        constraints = [width == 15, height == 20]
        font = 'bold 12pt Consolas'
        text = 'C'
        clicked::
            _internal.cancel_edition()
    PushButton: ok:
        constraints = [width == 15, height == 20]
        font = 'bold 12pt Consolas'
        text = '>'
        clicked::
            _internal.update_model()

# TODO add header dialog

enamldef SingleInstrDial(Dialog):
    attr model
    attr ui

    title = 'Panel properties'    
    
    Container:

        Conditional: corrupt:
            condition << bool(model._check_driver_state.__func__ is not
                                 SingleInstrPanel._check_driver_state.__func__)  
            CheckBox:
                text = 'Check for corruption'
                checked := model.check_corrupt
            FloatField:
                value := model.corrupt_time
                tool_tip = 'Time to wait before checking for instr corruption'
            Label:
                text = 's'

        Conditional: fast:
            condition << bool(model.fast_refresh_members)
            CheckBox:
                text = 'Fast refresh'
                checked := model.fast_refresh
            FloatField:
                value := model.fast_refresh_time
                tool_tip << 'Time to wait before refreshing the \
                                values : {}'.format(model.fast_refresh_members)
            Label:
                text = 's'

        Label: refresh_lab:
            text = 'Refresh time'
        FloatField: refresh_time:
            value := model.corrupt_time
            tool_tip = 'Time to wait before refreshing all the instrument \
                        values'
        Label: refresh_unit:
            text = 's'
        
        CheckBox: header:
            text = 'Use for header'
            checked := model.use_for_header
        PushButton: header_ed:
            text = 'Edit header'

        Include:
            objects << [ui(model = model)] if ui else []           

enamldef SingleInstrDock(DockItem):
    attr model
    attr main_ui
    attr second_ui
    attr prop_ui = second_ui
    
    title := model.title
    title_editable = True
    
    Container:
        enabled << model.profile_available
        Container:
            padding = 0
            enabled << model.profile_in_use
            ToolBar: tools:
                Action:
                    text = 'R'
                    tool_tip = 'Refresh entries'
                    triggered ::
                        model.refresh_driver_info()
                Action:
                    text = 'V'
                    tool_tip = 'Validate all'
                    visible << model.display_additional
                    triggered ::
                        result = question(tools, 'Confirm validation',
                                       cleandoc('''Confirm that you want all 
                                        pending infos to be sent to the instr 
                                        !'''))
                        if result is not None and result.action == 'accept':
                            model.validate_all = True
                Action:
                    text = 'C'
                    tool_tip = 'Cancel all'
                    visible << model.display_additional
                    triggered ::
                        model.cancel_all = True
                Action:
                    text = 'P'
                    tool_tip = 'Edit properties'
                    triggered ::
                        SingleInstrDial(model = model, ui = prop_ui).exec_()    
            Include:
                objects << [main_ui(model = model)] if main_ui else []
            Conditional:
                condition << model.display_additional
                Container:
                    padding = 0
                    Include:
                        objects << [second_ui(model = model)]\
                                                if second_ui else []
        Conditional:
            condition << bool(model.error)
            Container:
                padding = 0
                MultilineField:
                    text << model.error
                    read_only = True
                    maximum_size = (-1,50)
                PushButton:
                    text = 'Attempt to reconnect to instr'
                    clicked ::
                        model.restart_driver()
                    
    closed ::
        model.release_driver()