# -*- coding: utf-8 -*-
# =============================================================================
# module : pulses/pulses_views.enaml
# author : Matthieu Dartiailh
# license : MIT license
# =============================================================================
"""
"""
from enaml.layout.api import hbox, vbox
from enaml.widgets.api import (Container, Label, GroupBox, CheckBox, Splitter,
                               SplitItem, FlowItem, FlowArea, ObjectCombo)
from enaml.core.api import Conditional, Include

from hqc_meas.utils.widgets.qt_line_completer import QtLineCompleter


def default_add_displays(core, item):
    if item.kind == 'analogical':
        mod_view = ModulationView(item, item.modulation)

        cmd = 'hqc_meas.pulses_manager.shapes_request'
        shapes, _ = core.invoke_command(cmd,
                                        {'shapes': item.shape.shape_class,
                                         'use_class_name': True})
        shape = shapes[item.shape.shape_class]
        add_displays.append(shape[1](item==item, shape=item.shape))


EVALUATER_TOOLTIP = '\n'.join([
    fill(cleandoc("""In this field you can enter a text and
                  include fields which will be replaced by database
                  entries by using the delimiters '{' and '}' and
                  which will then be evaluated."""), 80),
    "Available math functions:",
    "- cos, sin, tan, acos, asin, atan, atan2",
    "- exp, log, log10, cosh, sinh, tanh, sqrt",
    "- complex math function are available under cm",
    "- numpy function are avilable under np",
    "- pi is available as Pi"])


enamldef ModulationView(FlowItem):
    """ View for the modulation of an analogical pulse.

    """
    attr item
    attr modulation

    GroupBox:
        title = 'Modulation'
        padding = 0
        constraints << [hbox(*self.widgets)]

        Label: kind_lab:
            text = 'Kind'
        ObjectCombo: kind_val:
            items = list(modulation.get_member('kind').items)
            selected := modulation.kind

        Splitter:
            SplitItem:
                Container:
                    constraints << [hbox(freq_lab, freq_val, freq_un)]
                    Label: freq_lab:
                        text = 'Frequency'
                    QtLineCompleter: freq_val:
                        hug_width = 'ignore'
                        text := modulation.frequency
                        entries_updater << item.root.get_bindable_vars
                        tool_tip = EVALUATER_TOOLTIP
                    ObjectCombo: freq_un:
                        items = list(modulation.get_member('frequency_unit').items)
                        selected := modulation.frequency_unit
            SplitItem:
                Container:
                    constraints << [hbox(phase_lab, phase_val, phase_un)]
                    Label: phase_lab:
                        text = 'Phase'
                    QtLineCompleter: phase_val:
                        hug_width = 'ignore'
                        text := modulation.phase
                        entries_updater << item.root.get_bindable_vars
                        tool_tip = EVALUATER_TOOLTIP
                    ObjectCombo: phase_un:
                        items = list(modulation.get_member('phase_unit').items)
                        selected := modulation.phase_unit


enamldef PulseView(GroupBox): view:
    """ View for a pulse item.

    """
    attr item
    attr context = item.root.context
    attr core
    attr add_displays = default_add_displays(core, item)
    attr pulse_state = core.invoke_command('hqc_meas.state.get',
                                           {'state':
                                            'hqc_meas.states.pulses_manager'})

    title << '{}'.format(item)
    hug_height = 'strong'

    constraints << [vbox(
                        hbox(kind_lab, kind_val, ch_lab, ch_val, def_lab,
                             def_val, *analog.items),
                        defs,
                        *add.items)]

    Label: kind_lab:
        text = 'Kind'
    ObjectCombo: kind_val:
        items = list(item.get_member('kind').items)
        selected := item.kind

    Label: ch_lab:
        text = 'Channel'
    ObjectCombo: ch_val:
        items << context.logical_channels if item.kind == 'logical' else\
                 context.analogical_channels
        selected := item.channel

    Label: def_lab:
        text = 'Mode'
    ObjectCombo: def_val:
        items << list(item.get_member('def_mode').items)
        selected := item.def_mode

    Splitter: defs:
        SplitItem:
            Container:
                padding = 0
                Label:
                    text << item.def_mode.split('/')[0]
                QtLineCompleter:
                    hug_width = 'ignore'
                    text := item.def_1
                    entries_updater << item.root.get_bindable_vars
                    tool_tip = EVALUATER_TOOLTIP
        SplitItem:
            Container:
                padding = 0
                Label:
                    text << item.def_mode.split('/')[1]
                QtLineCompleter:
                    hug_width = 'ignore'
                    text := item.def_2
                    entries_updater << item.root.get_bindable_vars
                    tool_tip = EVALUATER_TOOLTIP

    Conditional: analog:
        condition << item.kind == 'analogical'
        Label:
            text = 'Modulation'
        CheckBox:
            text = 'Active'
            checked := item.modulation.active
            checked ::
                if change['value']:
                    add_displays.insert(0, ModulationView(item,
                                                          item.modulation))
                else:
                    add_displays.pop(0)

        Label:
            text = 'Shape'
        ObjectCombo:
            items << pulse_state.shapes
            selected << item.shape.shape_class[:-5]  # Assume ends in Shape
            selected ::
                if change.get['oldvalue']:
                    add_displays.pop()
                cmd = 'hqc_meas.pulses_manager.shapes_request'
                shapes, _ = core.invoke_command(cmd,
                                                {'shapes': [change['value']]})
                shape = shapes[change['value']]
                item.shape = shape[0]()
                add_displays.append(shape[1](item==item, shape=shape))

    Conditional: add:
        condition << item.kind == 'analogical'
        FlowArea:
            margins = 2
            vertical_spacing = 5
            Include:
                objects << add_displays
